# Code Availability



## Over view
<img src="./mcplexpt/Figure/Readme_figure1.png" width="1100" />

* **Step1. Data Collection**: In this step, we measure and load the Fluid Thinning video images, extracting only the necessary images.
* **Step2. Data Processing**: Through processes such as whitening, cropping, and stacking, we create Merge Images. We also utilize Data Augmentation to increase the amount of data.
* **Step3. Model Training**: In this step, we use PCA and KNN methods to train the model for predicting fluid concentration.
* **Step4. Model Validation**: Using the Mean Squared Error (MSE) method, we determine hyperparameters like PCs (Principal Components), k, weights, and frames.
* **Step5. Model Testing**: Finally, we use the Test Data to predict fluid concentration using the trained model.


## Step1. Data Collection
The first step involves loading the acquired video data using the DoS-CaBER method, as described in the Introduction of our [paper](https://epicgit.snu.ac.kr/ttackpool/paper_minhyuckim_eigen_thinning/-/blob/main/sn-article.pdf). This step is executed through the dos.py file. The video frames are retrieved sequentially using `DoSCaBERExperiment.get_nth_image`. The frames where fluid thinning occurs and fluid pinch-off is observed are identified using the `DoSCaBERExperiment.capbridge_start` and `DoSCaBERExperiment.capbridge_broken` methods, respectively. For this study, we utilize these two frames and the frames in between them.

첫 번째 단계는 우리 페이퍼(연동)의 Introduction에서와 같이 DoS-CaBER를 사용하요 확보된 영상 데이터를 불러오는 단계이다. 해당 단계는 dos.py(강조) 파일을 통해 실행된다. 영상은 DoSCaBERExperiment.get_nth_image를 통해 frame 순서대로 불러와진다. DoSCaBERExperiment.capbridge_start와 DoSCaBERExperiment.capbridge_broken method를 통해 fluid thinning이 발생되는 frame과 fluid pinch-off가 발생하는 frame을 찾아낸다. 우리는 본 논문에서 그 2개의 frame과 그 사이의 frame들을 사용한다. [paper](https://epicgit.snu.ac.kr/ttackpool/paper_minhyuckim_eigen_thinning/-/blob/main/sn-article.pdf)

## Step2. Data Processing
The second step involves preprocessing the previously acquired image data into a format suitable for model construction. In this paper, two main data preprocessing methods were utilized. The first method aims to obtain Merge Images representing fluid thinning. This process is executed through the dos.py file, utilizing `DoSCaBERExperiment.Image_storage` . Within this method, the images are first whitened using the OpenCV library to enhance their features. Subsequently, cropping is applied based on the structural characteristics of the images to remove unnecessary data and align the images' centers. Each frame is then transformed, with white pixels being set to 255 divided by the total number of frames, and all frames are combined into a single image. Through this process, the fluid thinning video is consolidated into a single image. Additionally, weights are assigned to the images at the pinch-off points, as described in the Results and Discussion section of this paper and illustrated in Fig. 8 and Fig. 9.

The second data preprocessing method involves augmenting the image data. This process is executed through the `PCA.py` file in the [PCA]((https://epicgit.snu.ac.kr/ttackpool/code-availability.git)) directory, utilizing `PCA.pcaclass.augmentation`. This method represents a novel Fluid Thinning Augmentation approach implemented using PCA in this paper. It involves multiplying random ratios to the PCA scores corresponding to each PC, applying transformations, and then reconstructing the images. This results in slightly altered images based on the PCs. Image augmentation has been shown to enhance the accuracy of the model.

두 번째 단계는 앞서 확보한 이미지 데이터들을 모델 구축에 필요한 데이터 형태로 가공하는 단계이다. 본 논문에서는 크게 2개의 데이터 가공방법이 활용되었따. 첫 번째 가공방법은 Merge된 Fluid thinning 이미지를 얻는 방법이다. 이를 위해서는 이미지 데이터의 Whitening, Cropping, Stacking이 필요하다. 이는 dos.py(강조) 파일을 통해 실행된다. `DoSCaBERExperiment.Image_storage method`를 활용한다. 해당 method 에서는 OpenCV 라이브러리를 사용하여 이미지를 Whitening 한다. 또한 이미지의 형상적 특징을 기반으로 Cropping을 하여, 불필요한 이미지 데이터를 삭제하고 이미지의 Centering을 맞춘다. 각 Frame은 White pixel은 255/Number of total frames로 만들어지고 모든 frame들을 하나의 이미지로 합친다. 이과정을 통해 Fluid thinning 영상은 1개의 이미지로 통합된다. 마지막으로 필요에 따라 Pinch-off되는 시점의 이미지들에는 Weight가 주어진다. 이러한 과정의 필요성은 본 논문(연동)의 Results and discussion 과 Fig.8과 Fig.9에서 설명되어진다. 두 번째 가공방법은 Image data들을 Augmentation 하는 방법이다. 이는 [PCA]((https://epicgit.snu.ac.kr/ttackpool/code-availability.git)) 디렉토리의 `PCA.py` 파일을 통해 실행되어진다. `PCA.pcaclass.augmentation` 를 통해 구현된다. 이 방법은 본 논문에서 PCA를 통해 구현한 독자적인 Fluid thinning의 Augmentation 방법이다. 각 PC에 해당하는 PCA score값에 random ratio를 곱하여 변환을 주고 이를 reconstruction 해서 PCs가 조금 씩 변환된 Image들을 만들어 낸다. Image augmentation은 모델의 정확도 향상을 만든다.
## Step3. Model Training
The third step involves training a machine learning model to predict the concentration of mixed fluids. This step is executed through the `PCA.py` file in the [PCA]((https://epicgit.snu.ac.kr/ttackpool/code-availability.git)) directory. The concentration prediction model is constructed using `PCA.pcaclass.eigen`(Note: The method name may need modification for accuracy). The primary library utilized in this process is scikit-learn. Specifically, the `sklearn.decomposition.PCA` is applied for dimensionality reduction and noise removal, using PCA as one of the techniques. Subsequently, with the data processed by PCA, `sklearn.decomposition` and `sklearn.neighbors.KNeighborsClassifier` methods are employed to create a fluid concentration prediction model based on the K-Nearest Neighbors (KNN) algorithm.

세 번째 단계는 혼합 유체의 농도를 예측하는 Machine learning model을 트레이닝하는 단계이다. 해당 단계는 [PCA]((https://epicgit.snu.ac.kr/ttackpool/code-availability.git)) 디렉토리의 `PCA.py`파일을 통해 실행된다. `PCA.pcaclass.eigen(수정필요)`을 통해 농도 예측 모델은 만들어진다. scikit-learn 라이브러리가 주요하게 사용되었다. `sklearn.decomposition.PCA`을 통해 차원축소 및 노이즈 제거 방법 중 한가지인 PCA를 실행하였다. PCA가 적용된 데이터들과 `sklearn.decomposition와 sklearn.neighbors.KNeighborsClassifier`을 사용하여  `KNN 알고리즘` 기반의 유체농도 예측 모델을 만들었다. 

## Step4. Model Validation
The fourth step involves the validation phase to determine hyperparameters for improving the model's accuracy. This process is performed using `PCA.pcaclass.eigen_validation method (Note: The method name may need modification for accuracy)`. In our model, the method for calculating fluid concentration is explained in the Results and discussion section of the [paper](https://epicgit.snu.ac.kr/ttackpool/paper_minhyuckim_eigen_thinning/-/blob/main/sn-article.pdf). The `knn.predict_proba` is utilized to calculate the probabilities corresponding to each class of the validation data. Based on these probabilities, the concentration of the validation data is predicted. The `Mean Squared Error (MSE)` is then computed by comparing the predicted values with the actual labels. In this process, the parameter k for the class determination in KNN is set to 6. This value is determined based on the characteristics of the fluid prediction model and the Eigen-thinning images of explainable PCs.
Next, an iterative calculation is performed for the number of PCs obtained through PCA, the number of frames used for providing weights, and the extent of weight given. Ultimately, the combination of PCs' count, frame count, and weight value resulting in the lowest MSE is selected. While this paper utilizes MSE to predict fluid concentration, the method for calculating predicted values may vary depending on the user's objectives, potentially leading to different hyperparameters for enhancing model accuracy.

네 번째 단계는 모델의 정확도 향상을 위한 Hyper parameter 결정을 위한 Validation 단계이다. `PCA.pcaclass.eingen_validation(수정필요)`을 사용하여 진행된다. 우리의 모델에서 농도를 예측하는 계산 방식은 논문의 ~~에 부분에서 설명된다. `knn_proba`를 활용하여 validation data의 각 class에 해당하는 probability가 계산된다. probability를 기반으로 validation data의 농도가 예측된다. 예측값과 label값의 차이를 통해 `MSE(Mean Squre Error)`를 구한다. 이 때, KNN의 class 결정 parameter인 k 값은 6으로 설정되었다. 이 값은 유체를 예측하는 모델의 특성과 explainable한 PCs의 Eigen-thinning 이미지를 기반으로 설정되었다. 다음으로 PCA를 통해 얻어진 PCs의 갯수와 weight를 주는 frame의 수와 Weight의 정도에 대해 iterative한 계산을 시행한다. 최종적으로, iterative한 계산의 결과에서 MSE가 최소가 되는 PCs의 갯수, Frame의 수, Weight값이 결정된다. 본 논문에서는 유체의 농도를 예측하기 위해 이와 같은 방식으로 MSE를 구하였지만, 이는 사용자의 목적에 따라 예측값을 계산하는 과정이 달라질 수 있으며 이에 따라 Model 정확도를 향상시키는 Hyper parameter 역시 달라질 수 있다.

## Step5. Model Testing
The fifth step involves the testing phase, where fluid concentration is predicted using the model. The `PCA.pcaclass.Ratio_plot` is utilized for this purpose. In this step, the determined PCs need to be input as parameters. As a result, the actual and predicted concentrations are represented as a Bar graph image.


다섯 번째 단계는 모델을 테스트하는 단계로, 유체의 농도를 예측하는 단계이다. `PCA.pcaclass.Ratio_plot`을 활용한다. 이 때는 결정된 PCs가 parameter로 입력되어야 한다. 결과적으로 실제 농도와 예측된 농도가 Bar graph image로 표현된다.

